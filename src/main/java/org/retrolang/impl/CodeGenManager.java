package org.retrolang.impl;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import java.util.function.Supplier;
import org.retrolang.code.DebugInfo;
import org.retrolang.util.StringUtil;

public class CodeGenManager {
  final Scope scope;

  private CodeGenDebugging debugging;

  /** We append an index to the method name to get a unique identifier for each generated method. */
  private int nextIndex;

  private Monitor monitor = DEFAULT_MONITOR;

  private int exlinedThreshold;
  private int loopThreshold;

  CodeGenManager(Scope scope) {
    this.scope = scope;
    exlinedThreshold = Defaults.exlinedThreshold;
    loopThreshold = Defaults.loopThreshold;
  }

  /** Should be called before this scope is shared with other threads. */
  void enableCodeGenDebugging() {
    debugging = new CodeGenDebugging();
    TState.updateCodeGenDebugging();
  }

  CodeGenDebugging debugging() {
    return debugging;
  }

  int threshold(CodeGenLink.Kind kind) {
    return (kind == CodeGenLink.Kind.EXLINED) ? exlinedThreshold : loopThreshold;
  }

  void setThresholds(int exlined, int loop) {
    exlinedThreshold = exlined;
    loopThreshold = loop;
  }

  /**
   * Returns a distinct index.  Not thread-safe, but that's OK because only one thread at a time
   * generates code for a Scope.
   */
  int nextIndex() {
    assert Thread.holdsLock(this);
    return nextIndex++;
  }

  void setMonitor(Monitor monitor) {
    this.monitor = monitor;
  }

  Monitor monitor() {
    return monitor;
  }

  /**
   * A Monitor is an object that will be updated as code is generated, to enable logging or other
   * tracking of progress.
   */
  public interface Monitor {
    /**
     * Called once for each target in the group, after code has been generated for that target.
     *
     * @param name will appear in any stack traces thrown while executing the constructed method
     * @param args templates for the args that the generated code can accept
     * @param counter if {@link #countCalls} returned true, a Supplier that will return the call
     *     counter's current value together with the name of the generated method
     * @param debugInfo the CodeBuilder's {@link DebugInfo}
     */
    void loaded(
        String name, ImmutableList<Template> args, Supplier<String> counter, DebugInfo debugInfo);

    /**
     * Returns true if each generated method should include code to count the number of times it is
     * called. The default implementation returns false.
     */
    default boolean countCalls() {
      return false;
    }

    /**
     * Returns true if CodeBuilders should be configured to generate verbose output. The default
     * implementation returns false.
     */
    default boolean verbose() {
      return false;
    }

    /** Formats the generated bytecode. */
    static String dumpBytecode(DebugInfo debugInfo) {
      return DebugInfo.printConstants(debugInfo.constants, Handle.lookup)
          + "\n"
          + DebugInfo.printClassBytes(debugInfo.classBytes);
    }
  }

  private static final Monitor DEFAULT_MONITOR =
      (name, args, counter, debugInfo) -> {
        String argsAsString = StringUtil.joinElements("(", ")", args.size(), args::get);
        System.out.format("Loaded code for %s%s", name, argsAsString);
      };

  /**
   * See https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom for why this is in a
   * nested class.
   */
  private static class Defaults {
    // These are initialized once from system properties and then used by each new CodeGenManager
    static final int exlinedThreshold;
    static final int loopThreshold;

    static {
      boolean cgEnabled = Boolean.getBoolean("cgEnabled");
      exlinedThreshold = Integer.getInteger("exlinedCgThreshold", cgEnabled ? 20 : -1);
      loopThreshold = Integer.getInteger("loopCgThreshold", cgEnabled ? 10 : -1);
      Preconditions.checkState(exlinedThreshold != 0 && loopThreshold != 0);
    }
  }
}
