/*
 * Copyright 2025 The Retrospect Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.retrolang.impl;

import com.google.common.base.Preconditions;
import java.util.ArrayList;
import java.util.IdentityHashMap;
import java.util.Map;

/**
 * A CodeGenGroup contains one or more CodeGenTargets that we are generating code for. Once code
 * generation has completed for all of them, we will make them all ready. (If one CodeGenTarget has
 * exlined calls to another, we don't want to make the first ready until code generation for the
 * second has also completed.)
 *
 * <p>A Scope should only have one CodeGenGroup active at a time.
 */
class CodeGenGroup {

  final CodeGenManager manager;

  /** The CodeGenTargets for which we have decided to generate code. */
  private ArrayList<CodeGenTarget> targets = new ArrayList<>();

  /**
   * Each CodeGenLink we have encountered, mapped to the CodeGenTarget we have decided to use for it
   * (which will either have been previously generated or will be included in this group).
   */
  private Map<CodeGenLink, CodeGenTarget> linkMap = new IdentityHashMap<>();

  CodeGenGroup(CodeGenManager manager) {
    this.manager = manager;
  }

  /**
   * Create a new CodeGenTarget for the given link; must be called at least once before calling
   * {@link #generateCode}. (Calling it more than once is allowed but only done by tests; should not
   * be called more than once on the same link.)
   */
  void setup(CodeGenLink link) {
    CodeGenTarget previous = linkMap.put(link, newTarget(link));
    Preconditions.checkState(previous == null);
  }

  /**
   * Returns the target to be used for the given link. The result may be an previously-generated
   * target, or one being generated by this CodeGenGroup. Not thread-safe; should only be called by
   * the thread generating code for this group.
   */
  CodeGenTarget getTarget(CodeGenLink link) {
    return linkMap.computeIfAbsent(link, this::chooseTarget);
  }

  /**
   * Given a newly-encountered link, determines whether to use a previously-generated target or
   * generate a new one.
   */
  private CodeGenTarget chooseTarget(CodeGenLink link) {
    CodeGenTarget target = link.checkTarget(manager);
    return (target != null) ? target : newTarget(link);
  }

  /**
   * Create a new target for the given link and add it to the list of targets we will generate code
   * for.
   */
  private CodeGenTarget newTarget(CodeGenLink link) {
    CodeGenTarget target = link.newTarget(this);
    targets.add(target);
    return target;
  }

  /** Generates code for each target in the group, then makes them all ready. */
  void generateCode() {
    // First generate code for the added targets, which may cause more targets to be added.
    // (We don't use `for (target : targets)` because that wouldn't deal well with targets
    // being added while it runs.)
    for (int i = 0; i < targets.size(); i++) {
      targets.get(i).generateCode();
    }
    // Once we have code for the original target and any dependencies we can install it.
    // TODO: we might start executing any of this code as soon as the first makeReady() call
    // executes, which means we might be escape from a CodeGenTarget before it's installed;
    // could this cause a problem?
    for (CodeGenTarget target : targets) {
      target.link.makeReady(target, manager.debugging());
    }
    targets = null;
    linkMap = null;
  }
}
