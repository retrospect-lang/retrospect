// Based on https://code.earthengine.google.com/705ba57988f51d1ff90ebbc7bf33c83c

scale = size * size / 100
b0 = testBand(size * 0.3, size * 0.3, scale)
b1 = testBand(size * 0.3, size * 0.7, scale)
b2 = testBand(size * 0.7 , size * 0.5, scale)
b3 = [x, y] -> floor(x) + floor(y) * size
img = { b0, b1, b2, b3 }

// Create a (lazily-computed) matrix of features
features = matrix([size, size])
             | [i, j] -> feature([i - 0.5, j - 0.5], img)

centroids =
    [[0, 0, 0], [0.6, 0, 0], [0, 0.6, 0], [0, 0, 0.6], [0.55, 0.55, 0.55],
     [0.2, 0.2, 0], [0.2, 0, 0.2], [0, 0.2, 0.2],
     [0.1, 0.1, 0.3], [0.3, 0.1, 0.1], [0.1, 0.3, 0.1]]

// Classify each feature and save a list of the filtered results
filtered = features
     | f -> classify(f, centroids, keep)
     | filter(f -> f.filter == 0)
     | saveSequential

// Return the length of the list and its last element
return { count: size(filtered), last: filtered[size(filtered)] }

function testBand(xc, yc, scale) =
    [x, y] -> testBandHelper([x, y] - [xc, yc], scale)

function testBandHelper(delta, scale) {
  d = delta ** 2
  d2 = d[2] + d[1]
  return 1 / (log(d2 / scale + 7 - 6) + 1)
}

// Evaluate each of the bands at the given xy coordinates and save the results
// as a struct.
function feature(xy, bands) = bands | b -> b @ xy | save

// Translation of the "classify()" function in the code editor script, which
// given a feature with properties b0, b1, and b2, adds
// - a "distance<i>" property with the squared distance to each centroid
// - a "class" property with the index of the closest centroid
// - a "filter" property that will be 0 for 1 in <keep> of the features
function classify(f, centroids, keep) {
  b0 = f.b0
  b1 = f.b1
  b2 = f.b2
  b3 = f.b3
  pt = [b0, b1, b2]
  // Spammy because we're approximating the results of translating the EE
  // expression, where the loop is on the client side.
  distance0 = dist(pt, centroids[1])
  distance1 = dist(pt, centroids[2])
  distance2 = dist(pt, centroids[3])
  distance3 = dist(pt, centroids[4])
  distance4 = dist(pt, centroids[5])
  distance5 = dist(pt, centroids[6])
  distance6 = dist(pt, centroids[7])
  distance7 = dist(pt, centroids[8])
  distance8 = dist(pt, centroids[9])
  distance9 = dist(pt, centroids[10])
  distance10 = dist(pt, centroids[11])
  distances = [[distance0, 0],
               [distance1, 1],
               [distance2, 2],
               [distance3, 3],
               [distance4, 4],
               [distance5, 5],
               [distance6, 6],
               [distance7, 7],
               [distance8, 8],
               [distance9, 9],
               [distance10, 10]]
  min = distances | minAt([1])

  // We don't yet have a way to build the struct incrementally, so we
  // assemble it in a single step.
  return { b0, b1, b2, b3,
           distance0, distance1, distance2, distance3, distance4, distance5,
           distance6, distance7, distance8, distance9, distance10,
           class: min[2],
           filter: b3 % keep }
}

function dist(pt, centroid) = (centroid - pt) ** 2 | sum

/* RUN (size=200, keep=800) CODEGEN(10) RETURNS
{count: 50,
 last:
    {b0: 0.19868774362729588, b1: 0.2576687013636895, b2: 0.1890531704608046,
     b3: 39200, class: 10,
     distance0: 0.14161108039143833, distance1: 0.2631857880386832,
     distance10: 0.0194616767556045, distance2: 0.19240863875501088,
     distance3: 0.2747472758384728, distance4: 0.33916050339446935,
     distance5: 0.03906850239504415, distance6: 0.06651471475619812,
     distance7: 0.04292233166164067, distance8: 0.046907889116758465,
     distance9: 0.04305405985016195,
     filter: 0}}
---
?0--------------1-?0-1+..+?0-----?-----------.?-----------.--2-?0-----------.-2-?0-------------2-?0-2+...+0-2+...+0-2+...+0-2+...+0-2+...+0-2+...+0-2+...+0-------3+?∘0-3-0-3++++?0---1+..++..++..+..0-2+...++...++...+4bsrsrsrsrsrsrsrsr3++++++5bsr0-1+..++..++..+..0-4srsrsrsrsrsrsrsrsrsrsr5sr-1+..++..++..+..4srsrsrsrsrsrsrsrsrsrsr5sr0-6bsrsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr?-6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr7+6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr+6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr+6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr0-6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr7+6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr+6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr+6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr8+6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr7+6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr+6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr+6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr8+6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr7+9bs(4:33,6:9)r8+s(4:44,6:12)r+s(4:44,6:12)r+s(4:44,6:12)r+s(4:44,6:12)r+s(4:44,6:12)r+s(4:44,6:12)r+s(4:44,6:12)r+10bs(4:572,6:156)[5⊝?9⊝?10⊝0-?9⊝10⊝-?9⊝10⊝-?9⊝10⊝-?9⊝10⊝-9⊝10⊝-⊝-s(4:11,6:3)[7*9s(4:11,6:3)[⊕s(4:11,6:3)[⊕s(4:11,6:3)[⊕]]]10⊕s(4:11,6:3)[*9s(4:11,6:3)[⊕s(4:11,6:3)[⊕s(4:11,6:3)[⊕]]]10⊕s(4:11,6:3)[*9s(4:11,6:3)[⊕s(4:11,6:3)[⊕s(4:11,6:3)[⊕]]]10⊕s(4:11,6:3)[*9s(4:11,6:3)[⊕11bs(4:22,6:6)r]10⊕s(4:11,6:3)[*11s(4:33,6:9)r10⊕s(4:11,6:3)[*11s(4:33,6:9)r10⊕s(4:11,6:3)[*11s(4:33,6:9)r10⊕s(4:11,6:3)[*11s(4:33,6:9)r10⊕s(4:11,6:3)[*11s(4:33,6:9)r10⊕s(4:11,6:3)[*11s(4:33,6:9)r10⊕12bs(4:649,6:177)[11⊝12⊝0-6srsrsr..11⊝12⊝-4srsrsrsrsrsrsrsrsrsrsr5sr11⊝12⊝-6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr11⊕6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr11⊕6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr11⊕6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr11⊕6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr11⊕6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr11⊕6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr11⊕6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr11⊕6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr11⊕6srsrsr..4srsrsrsrsrsrsrsrsrsrsr5sr11⊕13bs(4:437679,6:119367)[⊝12⊝-]⊝-]]]]]]]]]]]]-
  0: x (top level)
  1: x sample_bench_2.r8t+2:37
  2: x sample_bench_2.r8t+2:85
  3: r LoopCore.Iterate // LoopCore.enumerateDefault // LoopCore.PipeCollectionCollector.enumerate // sample_bench_2.r8t+2:74_29 min = pipe(distances, _t0) // sample_bench_2.r8t+2:19_1 _t0 = classify(f, centroids, keep) // CollectionCore.AtTransformed.afterAt // CollectionCore.AtTransformed.at // CollectionCore.NextTransformedIterator.at // LoopCore.Iterate.next // LoopCore.PipeCollectionCollector.iterate // sample_bench_2.r8t+2:18_20 filtered = pipe(_t0, _t1)
  4: dist_x0 (2)
  5: iterate_r1 (3)
  6: at_x2 (1)
  7: r CollectionCore.NextTransformedIterator // LoopCore.Iterate.next // LoopCore.PipeCollectionCollector.iterate // sample_bench_2.r8t+2:18_20 filtered = pipe(_t0, _t1)
  8: r LoopCore.Iterate // LoopCore.PipeCollectionCollector.iterate // sample_bench_2.r8t+2:18_20 filtered = pipe(_t0, _t1)
  9: next_r3 (7)
 10: iterate_r4 (8)
 11: next_r5 (7)
 12: iterate_r6 (8)
 13: next_r7 (7)
---
allocated=7115552/94431, peak=9568
$0 = *[]x0:$1
$1 = *{b0: d4, b1: d12, b2: d20, b3: i0, class: b28, distance0: d36, distance1: d44, distance10: d52, distance2: d60, distance3: d68, distance4: d76, distance5: d84, distance6: d92, distance7: d100, distance8: d108, distance9: d116, filter: i32}
*/
