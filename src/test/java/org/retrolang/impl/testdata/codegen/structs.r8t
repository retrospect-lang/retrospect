// Verify code generation for some struct edge cases

if prep {
  _ = test({x: 1, y: 0}, {x: 3, y: 2, z: 6})
  _ = test({x: 0, y: 0}, {x: 5, y: "huh", z: "wat"})
  _ = test({x: 1, y: 1}, {x: 7, y: 1, z: 8})
}
return test({x: 1, y: 1}, {x: 9, y: "wat", z: "huh"})

function test(s1, s2) = withKeys(s1) | [k, v] -> (v == 0 ? Absent : s2 @ k) | save


/* CODEGEN test RETURNS
{x: 9, y: "wat"}
---
test_x0({x: i1, y: i2}, {x: i3, y: i4⸨0:i5; 1:x6:String⸩, z: i7⸨0:i8; 1:x9:String⸩}):
  1: CodeGenTarget.incrementCallCount(target:test_x0);
  2: test I1 == 0; F:→ 16
  3: I10 ← 1;
  4: I11 ← 0;
= 5: test I2 == 0; T:→ 18
  6: test I4 == 1; F:→ 20
  7: test Objects.equals(X6, "wat") == 0; T:→ 24
= 8: dropRef{X6, X9};
  9: I1 ← 2;
=10: TState.setResultTemplates(X0, [{x: i0⸨0:i4; 1:Absent⸩, y: i8⸨0:1; 1:Absent; 2:"wat"⸩}]);
 11: X2 ← TState.fnResultBytes(X0, 12);
 12: setInt[](X2, 4, I11);
 13: setInt[](X2, 0, I10);
 14: setInt[](X2, 8, I1);
 15: return
-16: I10 ← 0;
 17: I11 ← I3; → 5
-18: dropRef{X6, X9};
 19: I1 ← 1; → 10
-20: test I4 == 0; F:→ 8
 21: test I5 == 1; F:→ 24
 22: dropRef{X6, X9};
 23: I1 ← 0; → 10
-24: X12 ← newStackEntry(⟦StructCore.NextStructIterator.startLoop ∥ index=1, it=StructIterator({x: I1, y: I2}, EnumerateAllKeys, 1)⟧);
 25: X1 ← TState.fillStackEntry(X0, null, X12, ⟨⸨[x0:String, b0]; Absent⸩, StructIterator({x: b0, y: b0}, EnumerateAllKeys, b0)⟩, mMemo_1@xxxx, null);
 26: X1 ← TState.fillStackEntry(X0, X1, ⟦CollectionCore.NextWithKeysIterator.next⟧, ⟨⸨[x0:String, [x0:String, b0]]; Absent⸩, WithKeysIterator(StructIterator({x: b0, y: b0}, EnumerateAllKeys, b0)), TransformedIterator((empty), EnumerateAllKeys, lambda@8:46⸨s2={x: b0, y: ⸨b0; x0:String⸩, z: ⸨b0; x0:String⸩}⸩)⟩, mMemo_2@xxxx, null);
 27: X2 ← newStackEntry(⟦CollectionCore.NextTransformedIterator.next ∥ it=TransformedIterator((empty), EnumerateAllKeys, lambda@8:46⸨s2={x: I3, y: I4⸨0:I5; 1:X6⸩, z: I7⸨0:I8; 1:X9⸩}⸩)⟧);
 28: X1 ← TState.fillStackEntry(X0, X1, X2, ⟨⸨[x0:String, ⸨b0; Absent; "wat"⸩]; Absent⸩, TransformedIterator(WithKeysIterator(StructIterator({x: b0, y: b0}, EnumerateAllKeys, b0)), EnumerateAllKeys, lambda@8:46⸨s2={x: b0, y: ⸨b0; x0:String⸩, z: ⸨b0; x0:String⸩}⸩), SaverLoop(SaveElements), {x: ⸨b0; Absent⸩, y: ⸨1; Absent; "wat"⸩}⟩, mMemo_8@xxxx, null);
 29: X2 ← newStackEntry(⟦LoopCore.Iterate.next ∥ loop=SaverLoop(SaveElements), state={x: I10⸨0:I11; 1:Absent⸩, y: 1}⟧);
 30: X1 ← TState.fillStackEntry(X0, X1, X2, ⟨{x: ⸨b0; Absent⸩, y: ⸨1; Absent; "wat"⸩}, SaverLoop(SaveElements)⟩, mMemo_15@xxxx, null);
 31: X1 ← TState.fillStackEntry(X0, X1, ⟦LoopCore.enumerateDefault⟧, ⟨{x: ⸨b0; Absent⸩, y: ⸨1; Absent; "wat"⸩}, SaverLoop(SaveElements)⟩, mMemo_16@xxxx, null);
 32: X1 ← TState.fillStackEntry(X0, X1, ⟦LoopCore.PipeCollectionCollector.enumerate ∥ loop=SaverLoop(SaveElements)⟧, ⟨{x: ⸨b0; Absent⸩, y: ⸨1; Absent; "wat"⸩}⟩, mMemo_23@xxxx, null);
 33: X1 ← TState.fillStackEntry(X0, X1, ⟦structs.r8t+2:8_3 _t0 = pipe(_t0, _t1)⟧, ⟨{x: ⸨b0; Absent⸩, y: ⸨1; Absent; "wat"⸩}⟩, mMemo_x@xxxx, null);
 34: TState.setStackRest(X0, X1);
 35: TState.setUnwoundFrom(X0, target:test_x0);
 36: return
---
allocated=120/5, peak=48
*/
