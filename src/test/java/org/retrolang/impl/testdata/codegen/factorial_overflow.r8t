return factorial(prep ? 7 : 20)

function factorial(n) = n < 2 ? 1 : n * factorial(n - 1)

/* CODEGEN factorial ESCAPE_COUNT=8 RETURNS
2.43290200817664E18
---
factorial_x0(i1):
  1: CodeGenTarget.incrementCallCount(target:factorial_x0);
  2: X2 ← null;
  3: test I1 < 2; T:→ 16
  4: I3 ← Math.subtractExact(I1, 1); ArithmeticException:→ 24
  5: [i0] ← factorial_x0(X0, I3); X3 ← stackRest; unwind:→ 22
  6: I4 ← int[](TState.fnResultBytes(X0, 0), 0);
  7: TState.clearResultTemplates(X0);
  8: test X3 == null; T:→ 11
  9: X2 ← newStackEntry(⟦factorial_overflow.r8t+0:3_6 _t1 = factorial(_t1) ∥ n=I1⟧);
 10: X2 ← TState.fillStackEntry(X0, X3, X2, ⟨i0⟩, mMemo_x@xxxx, null);
-11: I3 ← Math.multiplyExact(I1, I4); ArithmeticException:→ 17
=12: TState.setResultTemplates(X0, [i0]);
 13: setInt[](TState.fnResultBytes(X0, 4), 0, I3);
 14: TState.setStackRest(X0, X2);
 15: return
-16: I3 ← 1; → 12
-17: X3 ← newStackEntry(⟦factorial_overflow.r8t+0:3_7 _t0 = multiply(n, _t1) ∥ n=I1, _t1=I4⟧);
 18: X2 ← TState.fillStackEntry(X0, null, X3, ⟨i0⟩, mMemo_x@xxxx, X2);
=19: TState.setStackRest(X0, X2);
 20: TState.setUnwoundFrom(X0, target:factorial_x0);
 21: return
-22: X2 ← newStackEntry(⟦factorial_overflow.r8t+0:3_6 _t1 = factorial(_t1) ∥ n=I1⟧);
 23: X2 ← TState.fillStackEntry(X0, X3, X2, ⟨i0⟩, mMemo_x@xxxx, null); → 19
-24: X2 ← newStackEntry(⟦factorial_overflow.r8t+0:3_0 _t1 = lessThan(n, 2) ∥ n=I1⟧);
 25: X2 ← TState.fillStackEntry(X0, null, X2, ⟨i0⟩, mMemo_x@xxxx, null); → 19
---
allocated=1704/60, peak=24
*/