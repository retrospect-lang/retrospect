// Find roots by bisection.
// This version uses a sequential loop.

fn = [x] -> x * x - 2
root1 = findRoot(fn, 0.5, 2.5, 1e-6)
root2 = findRoot(fn, -2.5, -0.5, 1e-6)
outOfBounds = findRoot(fn, 2, 3, 1e-6)
discontinuousFn = [x] -> (x > 1 ? 1 : -1)
discontinuous = findRoot(discontinuousFn, 0, 2, 1e-6)
return {discontinuous, outOfBounds, root1, root2}

// Returns an x in [xMin, xMax], or None
function findRoot(f, xMin, xMax, eps) {
  fxMin = f[xMin]
  fxMax = f[xMax]
  if abs(fxMin) <= eps {
    return xMin
  } else if abs(fxMax) <= eps {
    return xMax
  } else if fxMin < 0 and fxMax > 0 {
    x0 = xMin; x1 = xMax
  } else if fxMin > 0 and fxMax < 0 {
    x0 = xMax; x1 = xMin
  } else {
    return None
  }
  // Loop invariant: f[x0] < -eps, f[x1] > eps
  for sequential x0, x1 {
    xm = (x0 + x1) / 2
    if xm == x0 or xm == x1 {
      break { return None }
    }
    fxm = f[xm]
    if abs(fxm) <= eps {
      break { return xm }
    } else if (fxm < 0) {
      x0 = xm
    } else {
      x1 = xm
    }
  }
}

/* CODEGEN findRoot RETURNS
  {discontinuous: None,
   outOfBounds: None,
   root1: 1.4142136573791504,
   root2: -1.4142136573791504}
---
findRoot_x0(i1⸨0:lambda@1:9; 1:lambda@5:22⸩, d2, d3, 1.0E-6):
  1: CodeGenTarget.incrementCallCount(target:findRoot_x0);
  2: test I1 0 (< 2); T:→ 14
  3: test D2 == 0; F:→ 20
  4: test D4 == 2; F:→ 20
= 5: D6 ← D2;
  6: D2 ← D4;
= 7: D4 ← dDiv(dAdd(D6, D2), 2);
  8: test Double.isNaN(D4) == 0; F:→ 42
  9: test D4 == D6; T:→ 39
 10: test D4 == D2; T:→ 42
 11: test I1 1 (< 2); F:→ 28
 12: test 1 < D4; T:→ 31
=13: D6 ← D4; → 7
-14: D6 ← dSub(dMul(D2, D2), 2);
 15: test 1.0E-6 < Math.abs(D6); F:→ 20
 16: D8 ← dSub(dMul(D4, D4), 2);
 17: test 1.0E-6 < Math.abs(D8); F:→ 20
 18: test D6 < 0; F:→ 25
 19: test 0 < D8; T:→ 5
=20: X6 ← newStackEntry(⟦bisection.r8t+3:11_0 fxMin = at(f, [xMin]) ∥ f=I1⸨0:lambda@1:9; 1:lambda@5:22⸩, xMin=D2, xMax=D4, eps=1.0E-6⟧);
 21: X1 ← TState.fillStackEntry(X0, null, X6, ⟨⸨d0; None⸩⟩, mMemo_x@xxxx, null);
=22: TState.setStackRest(X0, X1);
 23: TState.setUnwoundFrom(X0, target:findRoot_x0);
 24: return
-25: test 0 < D6; F:→ 20
 26: test D8 < 0; F:→ 32
 27: D6 ← D4; → 7
-28: D8 ← dSub(dMul(D4, D4), 2);
 29: test 1.0E-6 < Math.abs(D8); F:→ 41
 30: test D8 < 0; T:→ 13
-31: D2 ← D4; → 7
-32: D4 ← 0;
 33: I1 ← 1;
=34: TState.setResultTemplates(X0, [i0⸨0:d8; 1:None⸩]);
 35: X2 ← TState.fnResultBytes(X0, 16);
 36: setDouble[](X2, 8, D4);
 37: setInt[](X2, 0, I1);
 38: return
-39: D4 ← 0;
 40: I1 ← 1; → 34
-41: I1 ← 0; → 34
-42: X4 ← newStackEntry(⟦LoopCore.IterateUnbounded.afterAt ∥ state=loop@25_state⸨x0=D6, x1=D2⸩, lambda=loop@25⸨f=I1⸨0:lambda@1:9; 1:lambda@5:22⸩, eps=1.0E-6⸩⟧);
 43: X1 ← TState.fillStackEntry(X0, null, X4, ⟨LoopExit(⸨loop@25_break@28; loop@25_break@32⸨xm=d0⸩⸩)⟩, LmMemo_20@xxxx, null);
 44: X1 ← TState.fillStackEntry(X0, X1, ⟦bisection.r8t+3:25_30 _t0 = iterateUnbounded(loop@25⸨f=f, eps=eps⸩, loop@25_state⸨x0=x0, x1=x1⸩)⟧, ⟨⸨d0; None⸩⟩, mMemo_x@xxxx, null); → 22
---
allocated=304/10, peak=104
*/
