// Create, walk, and drop a lot of binary trees, based on
// https://benchmarksgame-team.pages.debian.net/benchmarksgame/description/binarytrees.html

minDepth = 4
maxDepth = max(minDepth + 2, n)
stretchDepth = maxDepth + 1
stretchCheck = check(createTree(stretchDepth))

longLivedTree = createTree(maxDepth)
depth = minDepth
for sequential depth {
  if depth > maxDepth { break }
  iterations = number(bitShift(u32(1), maxDepth - depth + minDepth))
  check = 1..iterations | -> check(createTree(depth)) | sum
  results << { iterations, depth, check }
  depth += 2
} collect {
  results =| saveSequential
}
longLivedCheck = check(longLivedTree)
return { stretchDepth, stretchCheck, results, longLivedCheck }

//

compound TreeNode

function createTree(depth) =
    (depth == 0) ? TreeNode_([None, None])
                 : TreeNode_([createTree(depth - 1), createTree(depth - 1)])

function check(TreeNode tree) {
  [left, right] = tree_
  return left is None ? 1 : check(left) + check(right) + 1
}

/* RUN (n=10) CODEGEN(5) RETURNS
  {longLivedCheck: 2047,
   results:
      [{check: 31744, depth: 4, iterations: 1024},
       {check: 32512, depth: 6, iterations: 256},
       {check: 32704, depth: 8, iterations: 64},
       {check: 32752, depth: 10, iterations: 16}],
   stretchCheck: 4095,
   stretchDepth: 11}
---
0--1-?-++++?∘++++++++++2bsr**?⊝s(2:14)[⊕]?⊚s(2:15)[⊕][s(2:14)[⊕]?⊚]s(2:16)[⊕][s(2:14)[⊕]⊕][s(2:15)[⊕][s(2:14)[⊕]⊕]⊕]s(2:17)[⊕][s(2:14)[⊕]⊕3b]2[3s(3:30)r*]2[3s(3:62)r*]s(3:254)rs(3:510)rs(3:1022)rs(3:2046)r0--4-?-++++++?∘++++++++++5bsr**s(5:14)rs(5:30)rs(5:62)rs(5:126)rs(5:254)r?⊝s(5:510)r?⊝s(5:1022)rs(5:2046)r?0-3s(3:2046)r----s(3:30)r-5s(5:30)r---3s(3:30)r5s(5:30)r-3s(3:30)r5s(5:30)r-3s(3:30)r5s(5:30)r6+3s(3:30)r5s(5:30)r+3s(3:30)r5s(5:30)r+3s(3:30)r5s(5:30)r+3s(3:30)r5s(5:30)r+7bs(3:31496,5:31496)[?⊝0-⊝-]?-⊝-⊝-⊝-3s(3:126)r5s(5:126)r7⊝-3s(3:126)r5s(5:126)r7⊕3s(3:126)r5s(5:126)r7⊚-3s(3:126)r5s(5:126)r7⊝-3s(3:126)r5s(5:126)r7⊕3s(3:126)r5s(5:126)r7⊕3s(3:126)r5s(5:126)r7⊕3s(3:126)r5s(5:126)r7⊕3s(3:126)r5s(5:126)r7⊕8bs(3:31369,5:31369)r-s(3:32704,5:32704)r-s(3:32752,5:32752)r9+?∘0-?-5s(5:2046)r-
  0: x (top level)
  1: x binary_trees.r8t+3:25
  2: createTree_x0 (1)
  3: createTree_x1 (1)
  4: x binary_trees.r8t+3:29
  5: check_x2 (4)
  6: r LoopCore.Iterate // LoopCore.enumerateDefault // LoopCore.PipeCollectionCollector.enumerate // binary_trees.r8t+3:11_15 check = pipe(_t0, _t1) // LoopCore.IterateUnbounded.at // binary_trees.r8t+3:8_10 _t0 = iterateUnbounded(loop@8⸨results_ro=results_ro, maxDepth=maxDepth, minDepth=minDepth⸩, loop@8_state⸨results_rw=_t0, depth=depth⸩)
  7: iterate_r3 (6)
  8: iterate_r4 (6)
  9: r LoopCore.IterateUnbounded // binary_trees.r8t+3:8_10 _t0 = iterateUnbounded(loop@8⸨results_ro=results_ro, maxDepth=maxDepth, minDepth=minDepth⸩, loop@8_state⸨results_rw=_t0, depth=depth⸩)
---
allocated=8164728/205103, peak=130576
$0 = *[b0⸨0:None; 1:TreeNode(x0:$0)⸩, b1⸨0:None; 1:TreeNode(x1:$0)⸩]
$1 = *[]{check: i0, depth: b1, iterations: i2}
*/
