if prep {
  _ = test(2)
  return test(8)
}
return test(25)

// Accumulate 1..i for increasing values of i until we have at least n values
function test(n) {
  len = 0
  // The more obvious way to write this is
  //      for i in 0.. sequential len { ...
  // ... but I want to also exercise unbounded loops
  i = 0
  for sequential i, len {
    result <<^ 1..i
    len += i
    if len >= n { break }
    i += 1
  } collect {
    result =| saveUnordered
  }
  return result
}

/* CODEGEN test RETURNS
[1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 7]
---
test_x0(i1):
  1: CodeGenTarget.incrementCallCount(target:test_x0);
  2: I3 ← 0;
  3: I4 ← 0;
  4: I5 ← 1;
  5: X2 ← [];
= 6: I6 ← Math.addExact(I4, I3); ArithmeticException:→ 38
  7: test I6 < I1; F:→ 21
  8: I7 ← Math.addExact(I3, 1); ArithmeticException:→ 38
  9: I3 ← I7;
 10: I4 ← I6;
 11: test I3 < 0; T:→ 40
 12: I5 ← 1;
=13: test I3 < I5; T:→ 6
 14: I6 ← Math.addExact(I5, 1); ArithmeticException:→ 38
 15: I7 ← Frame1i2x.i0(X2);
 16: test TState.reserveForChange(X0, *[]b0@xxxx, X2, iAdd(I7, 1)) == 0; T:→ 38
 17: X2 ← removeRange*[]b0@xxxx(X0, X2, I7, 0, 1);
 18: test I5 isUint8; F:→ 24
 19: setUint8[](Frame1i2x.x0(X2), I7, I5);
 20: I5 ← I6; → 13
-21: TState.setResultTemplates(X0, [x0:*[]@xxxx]);
 22: setObject[](TState.fnResults(X0, 1), 0, X2);
 23: return
-24: X8 ← newStackEntry(⟦ReducerCore.NextStateSaveUnordered.replace ∥ state=X2, index=I7, value=I5⟧);
 25: X2 ← TState.fillStackEntry(X0, null, X8, ⟨x0:*[]@xxxx, SaveUnordered, RangeIterator(b0, b0, None)⟩, mMemo_1@xxxx, null);
 26: X5 ← newStackEntry(⟦LoopCore.Iterate.nextState ∥ loop=SaveUnordered, it=RangeIterator(I6, I3, None)⟧);
 27: X2 ← TState.fillStackEntry(X0, X2, X5, ⟨x0:*[]@xxxx⟩, mMemo_4@xxxx, null);
=28: X2 ← TState.fillStackEntry(X0, X2, ⟦LoopCore.enumerateDefault⟧, ⟨x0:*[]@xxxx⟩, mMemo_5@xxxx, null);
 29: X2 ← TState.fillStackEntry(X0, X2, ⟦LoopCore.EmitAll.enumerate⟧, ⟨LoopRW(Absent, x0:*[]@xxxx)⟩, mMemo_6@xxxx, null);
 30: X5 ← newStackEntry(⟦emit_all.r8t+0:15_3 result_rw = emitAll(result_ro, result_rw, _t0) ∥ i=I3, len=I4, n=I1⟧);
 31: X2 ← TState.fillStackEntry(X0, X2, X5, ⟨⸨LoopExit(loop@14_break⸨result_rw=LoopRW(Absent, x0:*[]@xxxx)⸩); loop@14_state⸨result_rw=LoopRW(Absent, x0:*[]@xxxx), i=b0, len=b0⸩⸩, loop@14⸨result_ro=LoopRO(EnumerateValues, SaveUnordered, True), n=b0⸩⟩, mMemo_18@xxxx, null);
 32: X3 ← newStackEntry(⟦LoopCore.IterateUnbounded.at ∥ lambda=loop@14⸨result_ro=LoopRO(EnumerateValues, SaveUnordered, True), n=I1⸩⟧);
 33: X1 ← TState.fillStackEntry(X0, X2, X3, ⟨LoopExit(loop@14_break⸨result_rw=LoopRW(Absent, x0:*[]@xxxx)⸩)⟩, mMemo_19@xxxx, null);
=34: X1 ← TState.fillStackEntry(X0, X1, ⟦emit_all.r8t+0:14_4 _t0 = iterateUnbounded(loop@14⸨result_ro=result_ro, n=n⸩, loop@14_state⸨result_rw=_t0, i=i, len=len⸩) ∥ result_ro=LoopRO(EnumerateValues, SaveUnordered, True)⟧, ⟨x0:*[]@xxxx⟩, mMemo_x@xxxx, null);
 35: TState.setStackRest(X0, X1);
 36: TState.setUnwoundFrom(X0, target:test_x0);
 37: return
-38: X6 ← newStackEntry(⟦LoopCore.Iterate.afterIterator ∥ it=RangeIterator(I5, I3, None), loop=SaveUnordered, state=X2⟧);
 39: X2 ← TState.fillStackEntry(X0, null, X6, ⟨x0:*[]@xxxx⟩, mMemo_4@xxxx, null); → 28
-40: X5 ← newStackEntry(⟦LoopCore.IterateUnbounded.afterAt ∥ state=loop@14_state⸨result_rw=LoopRW(Absent, X2), i=I3, len=I4⸩, lambda=loop@14⸨result_ro=LoopRO(EnumerateValues, SaveUnordered, True), n=I1⸩⟧);
 41: X1 ← TState.fillStackEntry(X0, null, X5, ⟨LoopExit(loop@14_break⸨result_rw=LoopRW(Absent, x0:*[]@xxxx)⸩)⟩, mMemo_19@xxxx, null); → 34
---
allocated=248/8, peak=80
*/