if prep {
  _ = test(0)
  _ = test(1)
  return test(2)
}
return test(5)

function test(n) = 1..n | -> makeArray(#) | -> (# | sum) | save

function makeArray(i) = 1..(2 * i) | save

/* CODEGEN test RETURNS
[3, 10, 21, 36, 55]
---
test_x0(i1):
  1: CodeGenTarget.incrementCallCount(target:test_x0);
  2: test I1 < 0; T:→ 69
  3: test I1 == 0; T:→ 29
  4: test TState.reserveForChange(X0, *[]b0@xxxx, null, I1) == 0; T:→ 69
  5: X3 ← alloc*[]b0@xxxx(X0, I1);
  6: I4 ← 1;
= 7: I5 ← Math.addExact(I4, 1); ArithmeticException:→ 67
  8: I2 ← Math.multiplyExact(2, I4); ArithmeticException:→ 67
  9: test I2 < 0; T:→ 67
 10: test I2 == 0; T:→ 67
 11: test TState.reserveForChange(X0, *[]b0@xxxx, null, I2) == 0; T:→ 67
 12: X6 ← alloc*[]b0@xxxx(X0, I2);
 13: I7 ← 1;
=14: I8 ← Math.addExact(I7, 1); ArithmeticException:→ 60
 15: test I7 < 1; T:→ 60
 16: test Frame1i2x.i0(X6) < I7; T:→ 60
 17: test I7 isUint8; F:→ 60
 18: setUint8[](Frame1i2x.x0(X6), iSub(I7, 1), I7);
 19: I7 ← I8;
 20: test I2 < I7; F:→ 14
 21: I2 ← 0;
 22: I7 ← 0;
=23: test I2 < Frame1i2x.i0(X6); F:→ 34
 24: I8 ← iAdd(I2, 1);
 25: I9 ← uint8[](Frame1i2x.x0(X6), I2);
 26: I9 ← Math.addExact(I7, I9); ArithmeticException:→ 48
 27: I2 ← I8;
 28: I7 ← I9; → 23
-29: X3 ← [];
=30: TState.setResultTemplates(X0, [x0:*[]@xxxx]);
 31: setObject[](TState.fnResults(X0, 1), 0, X3);
 32: return
=33: test I1 < I4; T:→ 30, F:→ 7
-34: dropRef{X6};
 35: test I4 < 1; T:→ 40
 36: test Frame1i2x.i0(X3) < I4; T:→ 40
 37: test I7 isUint8; F:→ 40
 38: setUint8[](Frame1i2x.x0(X3), iSub(I4, 1), I7);
 39: I4 ← I5; → 33
-40: X2 ← newStackEntry(⟦LoopCore.Iterate.afterNext ∥ element=[[I4], I7], it=TransformedIterator(RangeIterator(I5, I1, 0), EnumerateAllKeys, TransformedLambda(lambda@8:26, lambda@8:44)), loop=SaverLoop(SaveElements), state=X3⟧);
 41: X1 ← TState.fillStackEntry(X0, null, X2, ⟨x0:*[]@xxxx, SaverLoop(SaveElements)⟩, lmMemo_h41@xxxx, null);
=42: X1 ← TState.fillStackEntry(X0, X1, ⟦LoopCore.enumerateDefault⟧, ⟨x0:*[]@xxxx, SaverLoop(SaveElements)⟩, mMemo_h38@xxxx, null);
 43: X1 ← TState.fillStackEntry(X0, X1, ⟦LoopCore.PipeCollectionCollector.enumerate ∥ loop=SaverLoop(SaveElements)⟧, ⟨x0:*[]@xxxx⟩, mMemo_h45@xxxx, null);
 44: X1 ← TState.fillStackEntry(X0, X1, ⟦sums.r8t+0:8_4 _t0 = pipe(_t0, _t1)⟧, ⟨x0:*[]@xxxx⟩, mMemo_x@xxxx, null);
=45: TState.setStackRest(X0, X1);
 46: TState.setUnwoundFrom(X0, target:test_x0);
 47: return
-48: X8 ← newStackEntry(⟦ArrayCore.NextArrayIterator.startLoop ∥ index=I2, it=ArrayIterator(X6, EnumerateValues, I2)⟧);
 49: X2 ← TState.fillStackEntry(X0, null, X8, ⟨⸨b0; Absent⸩, ArrayIterator(x0:*[]@xxxx, EnumerateValues, b0), Sum(0), b0⟩, lmMemo_1@xxxx, null);
 50: X6 ← newStackEntry(⟦LoopCore.Iterate.next ∥ loop=Sum(0), state=I7⟧);
 51: X2 ← TState.fillStackEntry(X0, X2, X6, ⟨b0, Sum(0)⟩, lmMemo_7@xxxx, null);
 52: X2 ← TState.fillStackEntry(X0, X2, ⟦LoopCore.enumerateDefault⟧, ⟨b0, Sum(0)⟩, mMemo_8@xxxx, null);
 53: X2 ← TState.fillStackEntry(X0, X2, ⟦LoopCore.PipeCollectionCollector.enumerate ∥ loop=Sum(0)⟧, ⟨b0⟩, mMemo_12@xxxx, null);
 54: X2 ← TState.fillStackEntry(X0, X2, ⟦sums.r8t+0:8_1 _t0 = pipe(#, _t0)⟧, ⟨b0, [b0], RangeIterator(b0, b0, 0), TransformedIterator((empty), EnumerateAllKeys, TransformedLambda(lambda@8:26, lambda@8:44))⟩, mMemo_14@xxxx, null);
 55: X2 ← TState.fillStackEntry(X0, X2, ⟦CollectionCore.AtTransformed.afterAt⟧, ⟨b0, [b0], RangeIterator(b0, b0, 0), TransformedIterator((empty), EnumerateAllKeys, TransformedLambda(lambda@8:26, lambda@8:44))⟩, mMemo_h33@xxxx, null);
=56: X6 ← newStackEntry(⟦CollectionCore.NextTransformedIterator.at ∥ key=[I4], innerIt=RangeIterator(I5, I1, 0), it=TransformedIterator(ToBeSet, EnumerateAllKeys, TransformedLambda(lambda@8:26, lambda@8:44))⟧);
 57: X1 ← TState.fillStackEntry(X0, X2, X6, ⟨⸨[[b0], b0]; Absent⸩, TransformedIterator(RangeIterator(b0, b0, 0), EnumerateAllKeys, TransformedLambda(lambda@8:26, lambda@8:44)), SaverLoop(SaveElements), x0:*[]@xxxx⟩, lmMemo_35@xxxx, null);
=58: X2 ← newStackEntry(⟦LoopCore.Iterate.next ∥ loop=SaverLoop(SaveElements), state=X3⟧);
 59: X1 ← TState.fillStackEntry(X0, X1, X2, ⟨x0:*[]@xxxx, SaverLoop(SaveElements)⟩, lmMemo_h41@xxxx, null); → 42
-60: X8 ← newStackEntry(⟦LoopCore.Iterate.afterIterator ∥ it=RangeIterator(I7, I2, 0), loop=SaverLoop(SaveElements), state=X6⟧);
 61: X2 ← TState.fillStackEntry(X0, null, X8, ⟨x0:*[]@xxxx, SaverLoop(SaveElements)⟩, lmMemo_6@xxxx, null);
 62: X2 ← TState.fillStackEntry(X0, X2, ⟦LoopCore.enumerateDefault⟧, ⟨x0:*[]@xxxx, SaverLoop(SaveElements)⟩, mMemo_7@xxxx, null);
 63: X2 ← TState.fillStackEntry(X0, X2, ⟦LoopCore.PipeCollectionCollector.enumerate ∥ loop=SaverLoop(SaveElements)⟧, ⟨x0:*[]@xxxx⟩, mMemo_13@xxxx, null);
 64: X2 ← TState.fillStackEntry(X0, X2, ⟦sums.r8t+0:10_3 _t0 = pipe(_t0, _t1)⟧, ⟨x0:*[]@xxxx⟩, mMemo_17@xxxx, null);
 65: X2 ← TState.fillStackEntry(X0, X2, ⟦sums.r8t+0:8_0 _t0 = makeArray(#)⟧, ⟨x0:*[]@xxxx, lambda@8:44⟩, mMemo_18@xxxx, null);
 66: X2 ← TState.fillStackEntry(X0, X2, ⟦CollectionCore.AtTransformed.at ∥ second=lambda@8:44⟧, ⟨b0, [b0], RangeIterator(b0, b0, 0), TransformedIterator((empty), EnumerateAllKeys, TransformedLambda(lambda@8:26, lambda@8:44))⟩, mMemo_h33@xxxx, null); → 56
-67: X2 ← newStackEntry(⟦CollectionCore.NextTransformedIterator.loop ∥ innerIt=RangeIterator(I4, I1, 0), it=TransformedIterator(ToBeSet, EnumerateAllKeys, TransformedLambda(lambda@8:26, lambda@8:44))⟧);
 68: X1 ← TState.fillStackEntry(X0, null, X2, ⟨⸨[[b0], b0]; Absent⸩, TransformedIterator(RangeIterator(b0, b0, 0), EnumerateAllKeys, TransformedLambda(lambda@8:26, lambda@8:44)), SaverLoop(SaveElements), x0:*[]@xxxx⟩, lmMemo_35@xxxx, null); → 58
-69: X2 ← newStackEntry(⟦sums.r8t+0:8_0 _t0 = range(1, n) ∥ n=I1⟧);
 70: X1 ← TState.fillStackEntry(X0, null, X2, ⟨x0:*[]@xxxx⟩, mMemo_x@xxxx, null); → 45
---
allocated=416/15, peak=56
*/