if prep {
  _ = normTest(1)
  return normTest(2)
}
return normTest(3)

function normTest(n) {
  x = (-5..n) + n
  r1 = norm(x)
  r2 = norm(x | save)
  r3 = norm([n / 10, 0.4])
  return [r1, r2, r3]
}

function norm(v) = sqrt(v | x -> x ** 2 | sequentially(sum))

/* CODEGEN normTest RETURNS
[9.797958971132712, 9.797958971132712, 0.5]
---
normTest_x0(i1):
  1: CodeGenTarget.incrementCallCount(target:normTest_x0);
  2: test I1 < -6; T:→ 88
  3: I2 ← -5;
  4: I3 ← 0;
= 5: test I1 < I2; T:→ 12
  6: I4 ← Math.addExact(I2, 1); ArithmeticException:→ 80
  7: I5 ← Math.addExact(I2, I1); ArithmeticException:→ 80
  8: I5 ← Math.multiplyExact(I5, I5); ArithmeticException:→ 80
  9: I5 ← Math.addExact(I3, I5); ArithmeticException:→ 80
 10: I2 ← I4;
 11: I3 ← I5; → 5
-12: D4 ← Math.sqrt(I3);
 13: test Double.isNaN(D4) == 0; F:→ 80
 14: I6 ← Math.addExact(Math.subtractExact(I1, -5), 1); ArithmeticException:→ 80
 15: test I6 < 0; T:→ 80
 16: test I6 == 0; T:→ 80
 17: test TState.reserveForChange(X0, *[]i0@xxxx, null, I6) == 0; T:→ 80
 18: X3 ← alloc*[]i0@xxxx(X0, I6);
 19: I2 ← -5;
=20: test I1 < I2; T:→ 28
 21: I6 ← Math.addExact(I2, 1); ArithmeticException:→ 72
 22: I7 ← Math.addExact(6, I2); ArithmeticException:→ 72
 23: I8 ← Math.addExact(I2, I1); ArithmeticException:→ 72
 24: test I7 < 1; T:→ 72
 25: test Frame1i2x.i0(X3) < I7; T:→ 72
 26: setInt[](Frame1i2x.x0(X3), iShl(iSub(I7, 1), 2), I8);
 27: I2 ← I6; → 20
-28: I2 ← 0;
 29: I6 ← 0;
=30: test I2 < Frame1i2x.i0(X3); F:→ 37
 31: I7 ← iAdd(I2, 1);
 32: I8 ← int[](Frame1i2x.x0(X3), iShl(I2, 2));
 33: I8 ← Math.multiplyExact(I8, I8); ArithmeticException:→ 63
 34: I8 ← Math.addExact(I6, I8); ArithmeticException:→ 63
 35: I2 ← I7;
 36: I6 ← I8; → 30
-37: D7 ← Math.sqrt(I6);
 38: test Double.isNaN(D7) == 0; F:→ 63
 39: D9 ← dDiv(I1, 10);
 40: test Double.isNaN(D9) == 0; F:→ 63
 41: dropRef{X3};
 42: D11 ← dAdd(dMul(D9, D9), 0.16000000000000003);
 43: D1 ← Math.sqrt(D11);
 44: test Double.isNaN(D1) == 0; F:→ 51
 45: TState.setResultTemplates(X0, [[d0, d8, d16]]);
 46: X3 ← TState.fnResultBytes(X0, 24);
 47: setDouble[](X3, 0, D4);
 48: setDouble[](X3, 8, D7);
 49: setDouble[](X3, 16, D1);
 50: return
-51: X1 ← newStackEntry(⟦ArrayCore.NextArrayIterator.startLoop ∥ index=2, it=ArrayIterator([D9, 0.4], EnumerateValues, 2)⟧);
 52: X2 ← TState.fillStackEntry(X0, null, X1, ⟨⸨d0; Absent⸩, ArrayIterator([d0, 0.4], EnumerateValues, b0), TransformedIterator((empty), EnumerateValues, lambda@15:30)⟩, lmMemo_1@xxxx, null);
 53: X2 ← TState.fillStackEntry(X0, X2, ⟦CollectionCore.NextTransformedIterator.next ∥ it=TransformedIterator(ToBeSet, EnumerateValues, lambda@15:30)⟧, ⟨⸨d0; Absent⸩, TransformedIterator(ArrayIterator([d0, 0.4], EnumerateValues, b0), EnumerateValues, lambda@15:30), Sum(0), d0⟩, lmMemo_4@xxxx, null);
 54: X1 ← newStackEntry(⟦LoopCore.Iterate.next ∥ loop=Sum(0), state=D11⟧);
 55: X2 ← TState.fillStackEntry(X0, X2, X1, ⟨d0, Sum(0)⟩, lmMemo_11@xxxx, null);
 56: X2 ← TState.fillStackEntry(X0, X2, ⟦LoopCore.PipeCollectionCollector.iterate ∥ loop=Sum(0)⟧, ⟨d0⟩, mMemo_16@xxxx, null);
 57: X2 ← TState.fillStackEntry(X0, X2, ⟦doc_examples.r8t+0:15_3 _t0 = pipe(_t0, _t1)⟧, ⟨d0⟩, mMemo_23@xxxx, null);
 58: X1 ← newStackEntry(⟦doc_examples.r8t+0:11_7 r3 = norm([_t0, 0.4]) ∥ r1=D4, r2=D7⟧);
 59: X1 ← TState.fillStackEntry(X0, X2, X1, ⟨[d0, d0, d0]⟩, mMemo_x@xxxx, null);
=60: TState.setStackRest(X0, X1);
 61: TState.setUnwoundFrom(X0, target:normTest_x0);
 62: return
-63: X7 ← newStackEntry(⟦ArrayCore.NextArrayIterator.startLoop ∥ index=I2, it=ArrayIterator(X3, EnumerateValues, I2)⟧);
 64: X2 ← TState.fillStackEntry(X0, null, X7, ⟨⸨i0; Absent⸩, ArrayIterator(x0:*[]@xxxx, EnumerateValues, b0), TransformedIterator((empty), EnumerateValues, lambda@15:30)⟩, lmMemo_1@xxxx, null);
 65: X2 ← TState.fillStackEntry(X0, X2, ⟦CollectionCore.NextTransformedIterator.next ∥ it=TransformedIterator(ToBeSet, EnumerateValues, lambda@15:30)⟧, ⟨⸨b0; Absent⸩, TransformedIterator(ArrayIterator(x0:*[]@xxxx, EnumerateValues, b0), EnumerateValues, lambda@15:30), Sum(0), b0⟩, lmMemo_4@xxxx, null);
 66: X3 ← newStackEntry(⟦LoopCore.Iterate.next ∥ loop=Sum(0), state=I6⟧);
 67: X2 ← TState.fillStackEntry(X0, X2, X3, ⟨b0, Sum(0)⟩, LmMemo_11@xxxx, null);
 68: X2 ← TState.fillStackEntry(X0, X2, ⟦LoopCore.PipeCollectionCollector.iterate ∥ loop=Sum(0)⟧, ⟨b0⟩, mMemo_16@xxxx, null);
 69: X2 ← TState.fillStackEntry(X0, X2, ⟦doc_examples.r8t+0:15_3 _t0 = pipe(_t0, _t1)⟧, ⟨d0⟩, mMemo_23@xxxx, null);
 70: X3 ← newStackEntry(⟦doc_examples.r8t+0:10_5 r2 = norm(_t0) ∥ n=I1, r1=D4⟧);
 71: X1 ← TState.fillStackEntry(X0, X2, X3, ⟨[d0, d0, d0]⟩, mMemo_x@xxxx, null); → 60
-72: X6 ← newStackEntry(⟦CollectionCore.NextTransformedIterator.loop ∥ innerIt=RangeIterator(I2, I1, 6), it=TransformedIterator((empty), EnumerateAllKeys, `add:2:#.`(I1))⟧);
 73: X2 ← TState.fillStackEntry(X0, null, X6, ⟨⸨[[b0], i0]; Absent⸩, TransformedIterator(RangeIterator(i0, b0, 6), EnumerateAllKeys, `add:2:#.`(b0)), SaverLoop(SaveElements), x0:*[]@xxxx⟩, lmMemo_4@xxxx, null);
 74: X6 ← newStackEntry(⟦LoopCore.Iterate.next ∥ loop=SaverLoop(SaveElements), state=X3⟧);
 75: X2 ← TState.fillStackEntry(X0, X2, X6, ⟨x0:*[]@xxxx, SaverLoop(SaveElements)⟩, LmMemo_10@xxxx, null);
 76: X2 ← TState.fillStackEntry(X0, X2, ⟦LoopCore.enumerateDefault⟧, ⟨x0:*[]@xxxx, SaverLoop(SaveElements)⟩, mMemo_11@xxxx, null);
 77: X2 ← TState.fillStackEntry(X0, X2, ⟦LoopCore.PipeCollectionCollector.enumerate ∥ loop=SaverLoop(SaveElements)⟧, ⟨x0:*[]@xxxx⟩, mMemo_18@xxxx, null);
 78: X3 ← newStackEntry(⟦doc_examples.r8t+0:10_4 _t0 = pipe(x, _t0) ∥ n=I1, r1=D4⟧);
 79: X1 ← TState.fillStackEntry(X0, X2, X3, ⟨[d0, d0, d0]⟩, mMemo_x@xxxx, null); → 60
-80: X4 ← newStackEntry(⟦CollectionCore.NextTransformedIterator.loop ∥ innerIt=RangeIterator(I2, I1, None), it=TransformedIterator((empty), EnumerateValues, TransformedLambda(`add:2:#.`(I1), lambda@15:30))⟧);
 81: X2 ← TState.fillStackEntry(X0, null, X4, ⟨⸨b0; Absent⸩, TransformedIterator(RangeIterator(i0, b0, None), EnumerateValues, TransformedLambda(`add:2:#.`(b0), lambda@15:30)), Sum(0), b0⟩, lmMemo_7@xxxx, null);
 82: X4 ← newStackEntry(⟦LoopCore.Iterate.next ∥ loop=Sum(0), state=I3⟧);
 83: X2 ← TState.fillStackEntry(X0, X2, X4, ⟨b0, Sum(0)⟩, LmMemo_14@xxxx, null);
 84: X2 ← TState.fillStackEntry(X0, X2, ⟦LoopCore.PipeCollectionCollector.iterate ∥ loop=Sum(0)⟧, ⟨b0⟩, mMemo_19@xxxx, null);
 85: X2 ← TState.fillStackEntry(X0, X2, ⟦doc_examples.r8t+0:15_3 _t0 = pipe(_t0, _t1)⟧, ⟨d0⟩, mMemo_26@xxxx, null);
 86: X3 ← newStackEntry(⟦doc_examples.r8t+0:9_2 r1 = norm(x) ∥ n=I1, x=TransformedMatrix(Range(-5, I1), `add:2:#.`(I1))⟧);
 87: X1 ← TState.fillStackEntry(X0, X2, X3, ⟨[d0, d0, d0]⟩, mMemo_x@xxxx, null); → 60
-88: X2 ← newStackEntry(⟦doc_examples.r8t+0:8_0 _t0 = range(-5, n) ∥ n=I1⟧);
 89: X1 ← TState.fillStackEntry(X0, null, X2, ⟨[d0, d0, d0]⟩, mMemo_x@xxxx, null); → 60
---
allocated=288/10, peak=128
*/
