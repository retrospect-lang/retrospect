tree = Empty
nextValue = 1
for depth in 0..5 sequential tree, nextValue {
  size = 2 ** depth
  start = 0.5 / size
  for i in 1..size sequential tree, nextValue {
    tree[start * (2 * i - 1)] = nextValue
    nextValue += 1
  }
}
tree[19/32] = 1
return [tree[17/32], tree[18/32], tree[19/32], tree[1]]

type BST
compound NonEmpty is BST
singleton Empty is BST

method at(BST bst, [key]) {
  if bst is Empty {
    return Absent
  }
  rootKey = bst_.key
  if key < rootKey {
    return bst_.left[key]
  } else if key > rootKey {
    return bst_.right[key]
  } else {
    return bst_.value
  }
}

method replaceElement(BST bst, [key], value) {
  if bst is Empty {
    return NonEmpty_({key, value, left: Empty, right: Empty})
  }
  rootKey = bst_.key
  if key < rootKey {
    bst_.left[key] = value
  } else if key > rootKey {
    bst_.right[key] = value
  } else {
    bst_.value = value
  }
  return bst
}

/* CODEGEN at RETURNS
  [24, 12, 1, Absent]
---
at_x0(i1⸨0:NonEmpty(x2:*@xxxx); 1:Empty⸩, [d3]):
  1: CodeGenTarget.incrementCallCount(target:at_x0);
  2: X5 ← null;
  3: test I1 1 (< 2); T:→ 23
  4: test X2 is *{key: d4, left: b0⸨0:NonEmpty(x0:*@xxxx); 1:Empty⸩, right: b1⸨0:NonEmpty(x1:*@xxxx); 1:Empty⸩, value: b2}@xxxx; F:→ 45
  5: D6 ← Frame3i2x.d0(X2);
  6: test D3 < D6; F:→ 26
  7: test Frame3i2x.b0(X2) == 0; F:→ 45
  8: [i0⸨0:i4; 1:Absent⸩] ← at_x0(X0, 0, addRef(Frame3i2x.x0.getValue(X2)), D3); X1 ← stackRest; unwind:→ 43
  9: dropRef{X2};
 10: X2 ← TState.fnResultBytes(X0, 0);
 11: test int[](X2, 0) == 0; F:→ 44
 12: I3 ← int[](X2, 4);
 13: TState.clearResultTemplates(X0);
 14: test X1 == null; T:→ 16
 15: X5 ← TState.fillStackEntry(X0, X1, ⟦search_tree.r8t+0:24_10 _t0 = at(_t0, [key])⟧, ⟨⸨b0; Absent⸩⟩, mMemo_x@xxxx, null);
-16: I4 ← 0;
=17: TState.setResultTemplates(X0, [i0⸨0:i4; 1:Absent⸩]);
 18: X2 ← TState.fnResultBytes(X0, 8);
 19: setInt[](X2, 4, I3);
 20: setInt[](X2, 0, I4);
 21: TState.setStackRest(X0, X5);
 22: return
-23: dropRef{X2};
 24: I3 ← 0;
 25: I4 ← 1; → 17
-26: test D6 < D3; F:→ 35
 27: [i0⸨0:i4; 1:Absent⸩] ← at_x0(X0, Frame3i2x.b1(X2), addRef(Frame3i2x.x1.getValue(X2)), D3); X1 ← stackRest; unwind:→ 38
 28: dropRef{X2};
 29: X2 ← TState.fnResultBytes(X0, 0);
 30: I3 ← int[](X2, 4);
 31: I4 ← int[](X2, 0);
 32: TState.clearResultTemplates(X0);
 33: test X1 == null; T:→ 17
 34: X5 ← TState.fillStackEntry(X0, X1, ⟦search_tree.r8t+0:26_17 _t0 = at(_t0, [key])⟧, ⟨⸨b0; Absent⸩⟩, mMemo_x@xxxx, null); → 17
-35: I4 ← 0;
 36: I3 ← Frame3i2x.b2(X2);
 37: dropRef{X2}; → 17
-38: dropRef{X2};
 39: X5 ← TState.fillStackEntry(X0, X1, ⟦search_tree.r8t+0:26_17 _t0 = at(_t0, [key])⟧, ⟨⸨b0; Absent⸩⟩, mMemo_x@xxxx, null);
=40: TState.setStackRest(X0, X5);
 41: TState.setUnwoundFrom(X0, target:at_x0);
 42: return
-43: dropRef{X2};
-44: X5 ← TState.fillStackEntry(X0, X1, ⟦search_tree.r8t+0:24_10 _t0 = at(_t0, [key])⟧, ⟨⸨b0; Absent⸩⟩, mMemo_x@xxxx, null); → 40
-45: X1 ← newStackEntry(⟦search_tree.r8t+0:18_0 key = unarray1(_a0) ∥ bst=NonEmpty(X2), _a0=[D3]⟧);
 46: X5 ← TState.fillStackEntry(X0, null, X1, ⟨⸨b0; Absent⸩⟩, mMemo_x@xxxx, null); → 40
---
allocated=197704/7545, peak=56
*/