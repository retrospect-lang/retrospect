return recursiveFib(prep ? 6 : 8)

function recursiveFib(n) {
  if (n < 2) {
    return 1
  } else {
    r1 = recursiveFib(n - 1)
    r2 = recursiveFib(n - 2)
    if n > 3 {
      trace n
    }
    return r1 + r2
  }
}

/* CODEGEN recursiveFib RETURNS
34
---
recursiveFib_x0(i1):
  1: CodeGenTarget.incrementCallCount(target:recursiveFib_x0);
  2: X2 ← null;
  3: test I1 < 2; T:→ 26
  4: I3 ← Math.subtractExact(I1, 1); ArithmeticException:→ 38
  5: [i0] ← recursiveFib_x0(X0, I3); X3 ← stackRest; unwind:→ 36
  6: I4 ← int[](TState.fnResultBytes(X0, 0), 0);
  7: TState.clearResultTemplates(X0);
  8: test X3 == null; T:→ 11
  9: X2 ← newStackEntry(⟦trace.r8t+0:7_5 r1 = recursiveFib(_t0) ∥ n=I1⟧);
 10: X2 ← TState.fillStackEntry(X0, X3, X2, ⟨b0⟩, mMemo_x@xxxx, null);
-11: I3 ← Math.subtractExact(I1, 2); ArithmeticException:→ 34
 12: [i0] ← recursiveFib_x0(X0, I3); X3 ← stackRest; unwind:→ 32
 13: I5 ← int[](TState.fnResultBytes(X0, 0), 0);
 14: TState.clearResultTemplates(X0);
 15: test X3 == null; T:→ 18
 16: X6 ← newStackEntry(⟦trace.r8t+0:8_7 r2 = recursiveFib(_t0) ∥ n=I1, r1=I4⟧);
 17: X2 ← TState.fillStackEntry(X0, X3, X6, ⟨b0⟩, mMemo_x@xxxx, X2);
-18: test 3 < I1; F:→ 21
 19: X3 ← newStackEntry(⟦trace.r8t+0:10_10 trace n ∥ n=I1, r1=I4, r2=I5⟧);
 20: X2 ← TState.trace(X0, trace n, X3, X2);
-21: I1 ← Math.addExact(I4, I5); ArithmeticException:→ 27
=22: TState.setResultTemplates(X0, [i0]);
 23: setInt[](TState.fnResultBytes(X0, 4), 0, I1);
 24: TState.setStackRest(X0, X2);
 25: return
-26: I1 ← 1; → 22
-27: X1 ← newStackEntry(⟦trace.r8t+0:12_12 _t0 = add(r1, r2) ∥ r1=I4, r2=I5⟧);
 28: X2 ← TState.fillStackEntry(X0, null, X1, ⟨b0⟩, mMemo_x@xxxx, X2);
=29: TState.setStackRest(X0, X2);
 30: TState.setUnwoundFrom(X0, target:recursiveFib_x0);
 31: return
-32: X5 ← newStackEntry(⟦trace.r8t+0:8_7 r2 = recursiveFib(_t0) ∥ n=I1, r1=I4⟧);
 33: X2 ← TState.fillStackEntry(X0, X3, X5, ⟨b0⟩, mMemo_x@xxxx, X2); → 29
-34: X3 ← newStackEntry(⟦trace.r8t+0:8_6 _t0 = subtract(n, 2) ∥ n=I1, r1=I4⟧);
 35: X2 ← TState.fillStackEntry(X0, null, X3, ⟨b0⟩, mMemo_x@xxxx, X2); → 29
-36: X2 ← newStackEntry(⟦trace.r8t+0:7_5 r1 = recursiveFib(_t0) ∥ n=I1⟧);
 37: X2 ← TState.fillStackEntry(X0, X3, X2, ⟨b0⟩, mMemo_x@xxxx, null); → 29
-38: X2 ← newStackEntry(⟦trace.r8t+0:4_0 _t0 = lessThan(n, 2) ∥ n=I1⟧);
 39: X2 ← TState.fillStackEntry(X0, null, X2, ⟨b0⟩, mMemo_x@xxxx, null); → 29
---
            ⟦StackBase⟧
        (4) ⟦trace.r8t+0:1_6 _t0 = recursiveFib(_t0)⟧
        (3) ⟦trace.r8t+0:7_5 r1 = recursiveFib(_t0) ∥ n=8⟧
        (2) ⟦trace.r8t+0:7_5 r1 = recursiveFib(_t0) ∥ n=7⟧
        (1) ⟦trace.r8t+0:7_5 r1 = recursiveFib(_t0) ∥ n=6⟧
            ⟦trace.r8t+0:7_5 r1 = recursiveFib(_t0) ∥ n=5⟧
0.0s) ⟦trace.r8t+0:10_10 trace n ∥ n=4, r1=3, r2=2⟧
            ... (1) ...
0.0s) ⟦trace.r8t+0:10_10 trace n ∥ n=5, r1=5, r2=3⟧
            ... (2) ...
            ⟦trace.r8t+0:8_7 r2 = recursiveFib(_t0) ∥ n=6, r1=8⟧
0.0s) ⟦trace.r8t+0:10_10 trace n ∥ n=4, r1=3, r2=2⟧
            ... (2) ...
0.0s) ⟦trace.r8t+0:10_10 trace n ∥ n=6, r1=8, r2=5⟧
            ... (3) ...
        (5) ⟦trace.r8t+0:8_7 r2 = recursiveFib(_t0) ∥ n=7, r1=13⟧
            ⟦trace.r8t+0:7_5 r1 = recursiveFib(_t0) ∥ n=5⟧
0.0s) ⟦trace.r8t+0:10_10 trace n ∥ n=4, r1=3, r2=2⟧
            ... (5) ...
0.0s) ⟦trace.r8t+0:10_10 trace n ∥ n=5, r1=5, r2=3⟧
            ... (3) ...
0.0s) ⟦trace.r8t+0:10_10 trace n ∥ n=7, r1=13, r2=8⟧
            ... (4) ...
        (7) ⟦trace.r8t+0:8_7 r2 = recursiveFib(_t0) ∥ n=8, r1=21⟧
        (6) ⟦trace.r8t+0:7_5 r1 = recursiveFib(_t0) ∥ n=6⟧
            ⟦trace.r8t+0:7_5 r1 = recursiveFib(_t0) ∥ n=5⟧
0.0s) ⟦trace.r8t+0:10_10 trace n ∥ n=4, r1=3, r2=2⟧
            ... (6) ...
0.0s) ⟦trace.r8t+0:10_10 trace n ∥ n=5, r1=5, r2=3⟧
            ... (7) ...
            ⟦trace.r8t+0:8_7 r2 = recursiveFib(_t0) ∥ n=6, r1=8⟧
0.0s) ⟦trace.r8t+0:10_10 trace n ∥ n=4, r1=3, r2=2⟧
            ... (7) ...
0.0s) ⟦trace.r8t+0:10_10 trace n ∥ n=6, r1=8, r2=5⟧
            ... (4) ...
0.0s) ⟦trace.r8t+0:10_10 trace n ∥ n=8, r1=21, r2=13⟧
---
allocated=1976/51, peak=1904
*/
