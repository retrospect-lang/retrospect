if prep {
  _ = test([1, 2, 3])
  _ = test([2, 0, 4])
}
return [test([4, 5, 6]), test([3, 4, 0])]

function test(dims) {
  zero = newMatrix(sizes(dims), 0)
  keys = matrix(dims) | -> # - 1
  return keys | sum(zero)
}

/* CODEGEN test RETURNS
[[180, 240, 300], [0, 0, 0]]
---
test_x0([i1, i2, i3]):
  1: CodeGenTarget.incrementCallCount(target:test_x0);
  2: test I1 < 0; T:→ 66
  3: test I2 < 0; T:→ 66
  4: test I3 < 0; T:→ 66
  5: test I1 == 0; T:→ 28
  6: test I2 == 0; T:→ 28
  7: test I3 == 0; T:→ 28
  8: I4 ← 0;
  9: I8 ← 0;
 10: I9 ← 0;
 11: I5 ← 1;
 12: I6 ← 1;
 13: I7 ← 0;
=14: I7 ← iAdd(I7, 1);
=15: I10 ← Math.subtractExact(I5, 1); ArithmeticException:→ 61
 16: I11 ← Math.addExact(I4, I10); ArithmeticException:→ 61
 17: I4 ← Math.subtractExact(I6, 1); ArithmeticException:→ 56
 18: I12 ← Math.addExact(I8, I4); ArithmeticException:→ 56
 19: I4 ← Math.subtractExact(I7, 1); ArithmeticException:→ 41
 20: I10 ← Math.addExact(I9, I4); ArithmeticException:→ 41
 21: I4 ← I11;
 22: I8 ← I12;
 23: I9 ← I10;
 24: test I7 < I3; T:→ 14
 25: test I6 < I2; F:→ 37
 26: I6 ← iAdd(I6, 1);
 27: I7 ← 1; → 15
-28: I4 ← 0;
 29: I8 ← 0;
 30: I9 ← 0;
=31: TState.setResultTemplates(X0, [[i0, i4, i8]]);
 32: X1 ← TState.fnResultBytes(X0, 12);
 33: setInt[](X1, 0, I4);
 34: setInt[](X1, 4, I8);
 35: setInt[](X1, 8, I9);
 36: return
-37: test I5 < I1; F:→ 31
 38: I5 ← iAdd(I5, 1);
 39: I6 ← 1;
 40: I7 ← 1; → 15
-41: X4 ← newStackEntry(⟦ArrayCore.NextArrayIterator.startLoop ∥ index=2, it=ArrayIterator([I5, I6, I7], EnumerateAllKeys, 2)⟧);
 42: X10 ← TState.fillStackEntry(X0, null, X4, ⟨⸨[[b0], b0]; Absent⸩, ArrayIterator([b0, b0, b0], EnumerateAllKeys, b0), TransformedIterator((empty), EnumerateAllKeys, `subtract:2:#.`(1))⟩, lmMemo_1@xxxx, null);
 43: X10 ← TState.fillStackEntry(X0, X10, ⟦CollectionCore.NextTransformedIterator.next ∥ it=TransformedIterator(ToBeSet, EnumerateAllKeys, `subtract:2:#.`(1))⟧, ⟨⸨[[b0], b0]; Absent⸩, TransformedIterator(ArrayIterator([b0, b0, b0], EnumerateAllKeys, b0), EnumerateAllKeys, `subtract:2:#.`(1)), BinaryUpdateWithCollection(⟦`add:2`⟧), [b0, b0, i0]⟩, lmMemo_4@xxxx, null);
 44: X4 ← newStackEntry(⟦LoopCore.Iterate.next ∥ loop=BinaryUpdateWithCollection(⟦`add:2`⟧), state=[I11, I12, I9]⟧);
 45: X4 ← TState.fillStackEntry(X0, X10, X4, ⟨[b0, b0, i0], Sum([0, 0, 0]), TransformedIterator(BaseIterator(EnumerateValues, [b0, b0, b0], [b0, b0, b0]), EnumerateValues, lambda@9:24)⟩, lmMemo_13@xxxx, null);
=46: X4 ← TState.fillStackEntry(X0, X4, ⟦MatrixCore.BinaryUpdateMatrix.afterSizesRhs⟧, ⟨[b0, b0, i0], Sum([0, 0, 0]), TransformedIterator(BaseIterator(EnumerateValues, [b0, b0, b0], [b0, b0, b0]), EnumerateValues, lambda@9:24)⟩, mMemo_17@xxxx, null);
 47: X4 ← TState.fillStackEntry(X0, X4, ⟦ReducerCore.nextStateSum⟧, ⟨[b0, b0, i0], Sum([0, 0, 0]), TransformedIterator(BaseIterator(EnumerateValues, [b0, b0, b0], [b0, b0, b0]), EnumerateValues, lambda@9:24)⟩, mMemo_18@xxxx, null);
 48: X8 ← newStackEntry(⟦LoopCore.Iterate.nextState ∥ loop=Sum([0, 0, 0]), it=TransformedIterator(BaseIterator(EnumerateValues, [I5, I6, I7], [I1, I2, I3]), EnumerateValues, lambda@9:24)⟧);
 49: X1 ← TState.fillStackEntry(X0, X4, X8, ⟨[b0, b0, i0], Sum([0, 0, 0])⟩, LmMemo_28@xxxx, null);
 50: X1 ← TState.fillStackEntry(X0, X1, ⟦LoopCore.enumerateDefault⟧, ⟨[b0, b0, i0], Sum([0, 0, 0])⟩, mMemo_29@xxxx, null);
 51: X1 ← TState.fillStackEntry(X0, X1, ⟦LoopCore.PipeCollectionCollector.enumerate ∥ loop=Sum([0, 0, 0])⟧, ⟨[b0, b0, i0]⟩, mMemo_33@xxxx, null);
 52: X1 ← TState.fillStackEntry(X0, X1, ⟦matrix2.r8t+0:10_5 _t0 = pipe(keys, _t0)⟧, ⟨[b0, b0, i0]⟩, mMemo_x@xxxx, null);
=53: TState.setStackRest(X0, X1);
 54: TState.setUnwoundFrom(X0, target:test_x0);
 55: return
-56: X4 ← newStackEntry(⟦ArrayCore.NextArrayIterator.startLoop ∥ index=1, it=ArrayIterator([I5, I6, I7], EnumerateAllKeys, 1)⟧);
 57: X10 ← TState.fillStackEntry(X0, null, X4, ⟨⸨[[b0], b0]; Absent⸩, ArrayIterator([b0, b0, b0], EnumerateAllKeys, b0), TransformedIterator((empty), EnumerateAllKeys, `subtract:2:#.`(1))⟩, lmMemo_1@xxxx, null);
 58: X10 ← TState.fillStackEntry(X0, X10, ⟦CollectionCore.NextTransformedIterator.next ∥ it=TransformedIterator(ToBeSet, EnumerateAllKeys, `subtract:2:#.`(1))⟧, ⟨⸨[[b0], b0]; Absent⸩, TransformedIterator(ArrayIterator([b0, b0, b0], EnumerateAllKeys, b0), EnumerateAllKeys, `subtract:2:#.`(1)), BinaryUpdateWithCollection(⟦`add:2`⟧), [b0, b0, i0]⟩, lmMemo_4@xxxx, null);
 59: X4 ← newStackEntry(⟦LoopCore.Iterate.next ∥ loop=BinaryUpdateWithCollection(⟦`add:2`⟧), state=[I11, I8, I9]⟧);
 60: X4 ← TState.fillStackEntry(X0, X10, X4, ⟨[b0, b0, i0], Sum([0, 0, 0]), TransformedIterator(BaseIterator(EnumerateValues, [b0, b0, b0], [b0, b0, b0]), EnumerateValues, lambda@9:24)⟩, lmMemo_13@xxxx, null); → 46
-61: X10 ← newStackEntry(⟦ArrayCore.NextArrayIterator.startLoop ∥ index=0, it=ArrayIterator([I5, I6, I7], EnumerateAllKeys, 0)⟧);
 62: X10 ← TState.fillStackEntry(X0, null, X10, ⟨⸨[[b0], b0]; Absent⸩, ArrayIterator([b0, b0, b0], EnumerateAllKeys, b0), TransformedIterator((empty), EnumerateAllKeys, `subtract:2:#.`(1))⟩, lmMemo_1@xxxx, null);
 63: X10 ← TState.fillStackEntry(X0, X10, ⟦CollectionCore.NextTransformedIterator.next ∥ it=TransformedIterator(ToBeSet, EnumerateAllKeys, `subtract:2:#.`(1))⟧, ⟨⸨[[b0], b0]; Absent⸩, TransformedIterator(ArrayIterator([b0, b0, b0], EnumerateAllKeys, b0), EnumerateAllKeys, `subtract:2:#.`(1)), BinaryUpdateWithCollection(⟦`add:2`⟧), [b0, b0, i0]⟩, lmMemo_4@xxxx, null);
 64: X11 ← newStackEntry(⟦LoopCore.Iterate.next ∥ loop=BinaryUpdateWithCollection(⟦`add:2`⟧), state=[I4, I8, I9]⟧);
 65: X4 ← TState.fillStackEntry(X0, X10, X11, ⟨[b0, b0, i0], Sum([0, 0, 0]), TransformedIterator(BaseIterator(EnumerateValues, [b0, b0, b0], [b0, b0, b0]), EnumerateValues, lambda@9:24)⟩, lmMemo_13@xxxx, null); → 46
-66: X4 ← newStackEntry(⟦matrix2.r8t+0:8_0 _t0 = sizes(dims) ∥ dims=[I1, I2, I3]⟧);
 67: X1 ← TState.fillStackEntry(X0, null, X4, ⟨[b0, b0, i0]⟩, mMemo_x@xxxx, null); → 53
---
allocated=288/11, peak=184
*/
