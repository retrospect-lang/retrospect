package org.retrolang.impl;

import com.google.common.collect.ImmutableList;
import java.util.function.Supplier;
import org.retrolang.code.DebugInfo;
import org.retrolang.util.StringUtil;

public class CodeGenManager {
  final Scope scope;

  private CodeGenDebugging debugging;

  /** We append an index to the method name to get a unique identifier for each generated method. */
  private int nextIndex;

  private Monitor monitor = DEFAULT_MONITOR;

  CodeGenManager(Scope scope) {
    this.scope = scope;
  }

  /** Should be called before this scope is shared with other threads. */
  void enableCodeGenDebugging() {
    debugging = new CodeGenDebugging();
    TState.updateCodeGenDebugging();
  }

  CodeGenDebugging debugging() {
    return debugging;
  }

  int nextIndex() {
    return nextIndex++;
  }

  void setMonitor(Monitor monitor) {
    this.monitor = monitor;
  }

  Monitor monitor() {
    return monitor;
  }

  private static final Monitor DEFAULT_MONITOR =
      new Monitor() {
        @Override
        public void loaded(
            String name,
            ImmutableList<Template> args,
            Supplier<String> counter,
            DebugInfo debugInfo) {
          String argsAsString = StringUtil.joinElements("(", ")", args.size(), args::get);
          System.out.format("Loaded code for %s%s", name, argsAsString);
        }
      };

  /**
   * A Monitor is an object that will be updated as code is generated, to enable logging or other
   * tracking of progress.
   */
  public interface Monitor {
    /**
     * Called once for each target in the group, after code has been generated for that target.
     *
     * @param name will appear in any stack traces thrown while executing the constructed method
     * @param args templates for the args that the generated code can accept
     * @param counter if {@link #countCalls} returned true, a Supplier that will return the call
     *     counter's current value together with the name of the generated method
     * @param debugInfo the CodeBuilder's {@link DebugInfo}
     */
    void loaded(
        String name, ImmutableList<Template> args, Supplier<String> counter, DebugInfo debugInfo);

    /**
     * Returns true if each generated method should include code to count the number of times it is
     * called. The default implementation returns false.
     */
    default boolean countCalls() {
      return false;
    }

    /**
     * Returns true if CodeBuilders should be configured to generate verbose output. The default
     * implementation returns false.
     */
    default boolean verbose() {
      return false;
    }

    /** Formats the generated bytecode. */
    static String dumpBytecode(DebugInfo debugInfo) {
      return DebugInfo.printConstants(debugInfo.constants, Handle.lookup)
          + "\n"
          + DebugInfo.printClassBytes(debugInfo.classBytes);
    }
  }
}
